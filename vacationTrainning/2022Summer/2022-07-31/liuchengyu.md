# 补题报告

## 基本信息

队员一：刘骋羽

队员二：廖银

队员三：崔文贺

比赛链接：https://codeforces.com/gym/103463

## 做出来的题

### A A simple problem

题意：给我们一个数n，问我们0 ~ n这n + 1个数全排列组成的不含前导零的数中有多少个能被m整除。

思路：一开始暴搜写的，很明显过不了，n最大到15，复杂度大概15!，直接寄，而且组成的数字用long long也存不下，真这么写的话还得用__int128。暴搜不行，正解是状压dp（cwh tql），开一个dp[1 << 16][105]的数组，一维表示各种状态，二维表示当前状态对m求余的结果，dp[i][j]表示第i个状态对m求余结果为j的情况总数。接下来按部就班，枚举当前状态，枚举下一个状态，枚举二维求余的结果，最后的答案就是dp[(1 << (n + 1)) - 1][0]，为什么二维是0呢，对m求余为0是不是就代表着能被m整除？

### D Dup4 and pebble pile

题意：给了我们a ~ b这么多数，每次可以合并两堆，只需要满足这两堆中存在两个数有公共的素因子且这个素因子大于p就行，问我们合并到最后还剩下多少堆。

思路：并查集，我的做法比较麻烦，先把所有大于等于p小于等于b的素数筛出来，接着找到a ~ b中每个数大于等于p小于等于b的素因子，然后再跑a ~ b中的每个数，将每个数满足条件的素因子用并查集维护到同一个集合中，之后再跑一遍并查集，更新所有数的所属集合，最后有多少个数的集合答案就是多少。

### K LTS buy wine

题意：给你一个数组，每次只能从当前数组的两端取数，价值是i * v[j]，其中i是当前的次数，v[j]是第j个数的价值，问我们取完这个数组能得到的最大价值是多少。

思路：很明显的dp，刚开始我以为是线性dp，但实际上是区间dp。dp[l][r]表示l ~ r这个区间的最大价值，这里的意思是l ~ r这个区间还没被取，剩下的都已经被取光了。然后按照区间dp的套路写就行了，先把dp[i][i]附上初值，初值是n * v[i]，然后套板，外层循环枚举长度，内层循环枚举区间左端点，当前状态怎么转移呢？dp[i][j]可以由dp[i + 1][j]转移过来，表示当前这步取的是第i个数，也可以由dp[i][j - 1]转移过来，表示当前这步取的是第j个数，最后的答案就是dp[1][n]。

## 后面补的题

### H Hsueh- and keyboard

题意：给了我们几种操作，问我们把一个长度为x的字符串变成长度为n的字符串所需要的最少操作次数是多少。

思路：刚上来想到的是搜索，结果一看数据，1e6，太大，完全没戏。接着cwh说这题是最短路，但是不太会建图，这题就不了了之了。赛后补题时发现这题就是道最短路，点表示字符串的长度，边长表示操作次数，建图也很好建，一共有四种情况：一是单按一个键，能从i转移到i + 1，操作次数是1；二是(ctrl + a) + (ctrl + c) + (k - 1) * (ctrl + v)，能从i转移到k * i，操作次数是4 + 2 * (k - 1)；三是单按退格键，能从i转移到i - 1，操作次数是1；四是(ctrl + a) + 退格键，能从i转移到0，操作次数是3。但是在建图时有两个点要注意一下，一是当前长度为0时只能进行操作一，别的三个操作没有意义；二是要多跑点数据，比如说题目让我们从1跑到1e6，建图时就从0建到1e6 + 1e3，因为有的情况可能是先多跑点再删几个字符是最优解，这样就要在建图时多跑点，相应的变量也得开大点，要不然会运行错误。之后就没啥好说的了，直接跑堆优化的dijkstra就行。
